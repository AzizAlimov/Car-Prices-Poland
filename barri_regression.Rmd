---
title: "R Notebook"
output: html_notebook
---
# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(mlbench)
library(randomForest)
library(party)
library(rpart)
library(rpart.plot)
library(leaps)
library(olsrr)
library(magrittr)
library(tibble)
```

```{r}
n<-nrow(subset_selected)
set.seed(123)
n_s = sample(n,10000)
train = subset_selected[n_s, ]
```


```{r}
crossValidationCont = function(df,K,a,nperfmeas=6)
{ set.seed(123)
  n = nrow(df)
  nhold = round(n/K) # size of holdout set 
  iperm = sample(n)
  perfmeas = matrix(0,K,nperfmeas)  
  models = vector(mode="list", length=3)
  year = vector(mode="list", length=3)
  for(k in 1:K)
  { indices = (((k-1)*nhold+1):(k*nhold))
    if( k==K ) indices = (((k-1)*nhold+1):n)
    indices = iperm[indices]
    traine = df[-indices,]
    holdoute = df[indices,]
    models[[k]] = lm(price~mark_cat+year+mileage_cat+log_vol_engine+fuel+car_type,data=traine)
    pred = predict(models[[k]],newdata=holdoute,interval="prediction",level=a)
    RSS = c(crossprod(models[[k]]$residuals))
    MSE = RSS / length(models[[k]]$residuals)
    x = intervalScore(pred, holdoute$price, a)
    y= sqrt(MSE)
    z = summary(models[[k]])$r.squared
    perfmeas[k,1:4] = x$summary
    perfmeas[k,5] = y
    perfmeas[k,6] = z
    year[[k]] = traine$year
  }
  avgperfmeas = apply(perfmeas,2,mean)
  list(perfmeasbyfold=perfmeas, avgperfmeas=avgperfmeas, models= models, year= year)
}
```

```{r}
crossValidationCont2 = function(df,K,a,nperfmeas=6)
{ set.seed(123)
  n = nrow(df)
  nhold = round(n/K) # size of holdout set 
  iperm = sample(n)
  perfmeas = matrix(0,K,nperfmeas)  
  models = vector(mode="list", length=3)
  year = vector(mode="list", length=3)
  predi = vector(mode="list", length=3)
  pri = vector(mode="list", length=3)
  for(k in 1:K)
  { indices = (((k-1)*nhold+1):(k*nhold))
    if( k==K ) indices = (((k-1)*nhold+1):n)
    indices = iperm[indices]
    traine = df[-indices,]
    holdoute = df[indices,]
    models[[k]] = lm(price~mark_cat+year+mileage_cat+log_vol_engine+fuel+car_type,data=traine, weights = 1/(traine$year)^2)
    pred = predict(models[[k]],newdata=holdoute,interval="prediction",level=a, weights = 1/(holdoute$year)^2)
    RSS = c(crossprod(models[[k]]$residuals))
    MSE = RSS / length(models[[k]]$residuals)
    x = intervalScore(pred, holdoute$price, a)
    y= sqrt(MSE)
    z = summary(models[[k]])$r.squared
    perfmeas[k,1:4] = x$summary
    perfmeas[k,5] = y
    perfmeas[k,6] = z
    year[[k]] = traine$year
    predi[[k]] = pred
    pri[[k]] = holdoute$price
    #ols_step_best_subset( models[[k]])
  }
  avgperfmeas = apply(perfmeas,2,mean)
  list(perfmeasbyfold=perfmeas, avgperfmeas=avgperfmeas, models= models, year= year, pred = predi, price = pri)
}
```

```{r}
crossValidationCont3 = function(df,K,a,nperfmeas=6)
{ set.seed(123)
  n = nrow(df)
  nhold = round(n/K) # size of holdout set 
  iperm = sample(n)
  perfmeas = matrix(0,K,nperfmeas)  
  models = vector(mode="list", length=3)
  year = vector(mode="list", length=3)
  predi = vector(mode="list", length=3)
  pri = vector(mode="list", length=3)
  for(k in 1:K)
  { indices = (((k-1)*nhold+1):(k*nhold))
    if( k==K ) indices = (((k-1)*nhold+1):n)
    indices = iperm[indices]
    traine = df[-indices,]
    holdoute = df[indices,]
    models[[k]] = lm(I(log(price))~mark_cat+year+mileage_cat+log_vol_engine+fuel+car_type,data=traine)
    pred1 = predict(models[[k]],newdata=holdoute,interval="prediction",level=a)
    pred = exp(pred1)
    RSS = c(crossprod(models[[k]]$residuals))
    MSE = RSS / length(models[[k]]$residuals)
    x = intervalScore(pred, holdoute$price, a)
    y= sqrt(MSE)
    z = summary(models[[k]])$r.squared
    perfmeas[k,1:4] = x$summary
    perfmeas[k,5] = y
    perfmeas[k,6] = z
    year[[k]] = traine$year
    predi[[k]] = pred
    pri[[k]] = holdoute$price
  }
  avgperfmeas = apply(perfmeas,2,mean)
  list(perfmeasbyfold=perfmeas, avgperfmeas=avgperfmeas, models= models, year= year, pred = predi)
}
```

```{r}
intervalScore = function(predObj,actual,level) { 
n = nrow(predObj)
alpha = 1-level
ilow = (actual<predObj[,2]) # overestimation
ihigh = (actual>predObj[,3]) # underestimation
sumlength = sum(predObj[,3]-predObj[,2]) # sum of lengths of prediction intervals 
sumlow = sum(predObj[ilow,2]-actual[ilow])*2/alpha
sumhigh = sum(actual[ihigh]-predObj[ihigh,3])*2/alpha
avglength = sumlength/n
IS = (sumlength+sumlow+sumhigh)/n # average length + average under/over penalties 
cover = mean(actual>= predObj[,2] & actual<=predObj[,3])
summ = c(level,avglength,IS,cover)
# summary with level, average length, interval score, coverage rate, r^2, rmse
imiss = which(ilow | ihigh)
list(summary=summ, imiss=imiss)
}
x = crossValidationCont(train,3,0.5,6)
y = crossValidationCont2(train,3,0.5,6)
z = crossValidationCont3(train,3,0.5,6)
```















